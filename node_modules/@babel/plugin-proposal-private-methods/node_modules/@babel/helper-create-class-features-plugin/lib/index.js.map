{"version":3,"names":["types","t","nameFunction","splitExportDeclaration","buildPrivateNamesNodes","buildPrivateNamesMap","transformPrivateNamesUsage","buildFieldsInitNodes","buildCheckInRHS","buildDecoratedClass","hasDecorators","injectInitialization","extractComputedKeys","enableFeature","FEATURES","isLoose","shouldTransform","assertFieldTransformed","version","replace","split","reduce","v","x","versionKey","createClassFeaturePlugin","name","feature","loose","manipulateOptions","api","assumption","inherits","setPublicClassFields","privateFieldsAsSymbols","privateFieldsAsProperties","constantSuper","noDocumentAll","Error","privateFieldsAsSymbolsOrProperties","explicit","undefined","push","length","console","warn","join","pre","file","get","set","visitor","Class","path","isClassDeclaration","constructor","isDecorated","node","props","elements","computedPaths","privateNames","Set","body","isClassProperty","isClassMethod","computed","isPrivate","key","id","getName","setName","isClassPrivateMethod","kind","has","buildCodeFrameError","add","isProperty","isStaticBlock","innerBinding","ref","isClassExpression","scope","generateUidIdentifier","cloneNode","privateNamesMap","privateNamesNodes","keysNodes","staticNodes","instanceNodes","pureStaticNodes","wrapClass","superClass","referenceVisitor","state","prop","static","traverse","wrappedPath","insertBefore","insertAfter","find","parent","isStatement","isDeclaration","ExportDefaultDeclaration","decl","type"],"sources":["../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginAPI, PluginObject } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport {\n  buildPrivateNamesNodes,\n  buildPrivateNamesMap,\n  transformPrivateNamesUsage,\n  buildFieldsInitNodes,\n  buildCheckInRHS,\n} from \"./fields\";\nimport type { PropPath } from \"./fields\";\nimport { buildDecoratedClass, hasDecorators } from \"./decorators\";\nimport { injectInitialization, extractComputedKeys } from \"./misc\";\nimport { enableFeature, FEATURES, isLoose, shouldTransform } from \"./features\";\nimport { assertFieldTransformed } from \"./typescript\";\n\nexport { FEATURES, enableFeature, injectInitialization, buildCheckInRHS };\n\ndeclare const PACKAGE_JSON: { name: string; version: string };\n\n// Note: Versions are represented as an integer. e.g. 7.1.5 is represented\n//       as 70000100005. This method is easier than using a semver-parsing\n//       package, but it breaks if we release x.y.z where x, y or z are\n//       greater than 99_999.\nconst version = PACKAGE_JSON.version\n  .replace(/-.*$/, \"\")\n  .split(\".\")\n  .reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-class-features/version\";\n\ninterface Options {\n  name: string;\n  feature: number;\n  loose?: boolean;\n  inherits?: PluginObject[\"inherits\"];\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n  api?: PluginAPI;\n}\n\nexport function createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8): Remove the default value\n  api = { assumption: () => void 0 },\n  inherits,\n}: Options): PluginObject {\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(\n      `Cannot enable both the \"privateFieldsAsProperties\" and ` +\n        `\"privateFieldsAsSymbols\" assumptions as the same time.`,\n    );\n  }\n  const privateFieldsAsSymbolsOrProperties =\n    privateFieldsAsProperties || privateFieldsAsSymbols;\n\n  if (loose === true) {\n    type AssumptionName = Parameters<PluginAPI[\"assumption\"]>[0];\n    const explicit: `\"${AssumptionName}\"`[] = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(\n        `[${name}]: You are using the \"loose: true\" option and you are` +\n          ` explicitly setting a value for the ${explicit.join(\" and \")}` +\n          ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` +\n          ` can cause incompatibilities with the other class features` +\n          ` plugins, so it's recommended that you replace it with the` +\n          ` following top-level option:\\n` +\n          `\\t\"assumptions\": {\\n` +\n          `\\t\\t\"setPublicClassFields\": true,\\n` +\n          `\\t\\t\"privateFieldsAsSymbols\": true\\n` +\n          `\\t}`,\n      );\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n\n    pre(file) {\n      enableFeature(file, feature, loose);\n\n      if (!file.get(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, { file }) {\n        if (file.get(versionKey) !== version) return;\n\n        if (!shouldTransform(path, file)) return;\n\n        if (path.isClassDeclaration()) assertFieldTransformed(path);\n\n        const loose = isLoose(file, feature);\n\n        let constructor: NodePath<t.ClassMethod>;\n        const isDecorated = hasDecorators(path.node);\n        const props: PropPath[] = [];\n        const elements = [];\n        const computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[] = [];\n        const privateNames = new Set<string>();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          if (\n            // check path.node.computed is enough, but ts will complain\n            (path.isClassProperty() || path.isClassMethod()) &&\n            path.node.computed\n          ) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const { name } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (\n                  privateNames.has(getName) ||\n                  (privateNames.has(name) && !privateNames.has(setName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (\n                  privateNames.has(setName) ||\n                  (privateNames.has(name) && !privateNames.has(getName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (\n                (privateNames.has(name) &&\n                  !privateNames.has(getName) &&\n                  !privateNames.has(setName)) ||\n                (privateNames.has(name) &&\n                  (privateNames.has(getName) || privateNames.has(setName)))\n              ) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({ kind: \"constructor\" })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (\n              path.isProperty() ||\n              path.isPrivate() ||\n              path.isStaticBlock?.()\n            ) {\n              props.push(path as PropPath);\n            }\n          }\n        }\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (!props.length) return;\n        } else {\n          if (!props.length && !isDecorated) return;\n        }\n\n        const innerBinding = path.node.id;\n        let ref: t.Identifier;\n        if (!innerBinding || path.isClassExpression()) {\n          nameFunction(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = t.cloneNode(path.node.id);\n        }\n\n        // NODE: These three functions don't support decorators yet,\n        //       but verifyUsedFeatures throws if there are both\n        //       decorators and private fields.\n        const privateNamesMap = buildPrivateNamesMap(props);\n        const privateNamesNodes = buildPrivateNamesNodes(\n          privateNamesMap,\n          privateFieldsAsProperties ?? loose,\n          privateFieldsAsSymbols ?? false,\n          file,\n        );\n\n        transformPrivateNamesUsage(\n          ref,\n          path,\n          privateNamesMap,\n          {\n            privateFieldsAsProperties:\n              privateFieldsAsSymbolsOrProperties ?? loose,\n            noDocumentAll,\n            innerBinding,\n          },\n          file,\n        );\n\n        let keysNodes: t.Statement[],\n          staticNodes: t.Statement[],\n          instanceNodes: t.Statement[],\n          pureStaticNodes: t.FunctionDeclaration[],\n          wrapClass: (path: NodePath<t.Class>) => NodePath;\n\n        if (!process.env.BABEL_8_BREAKING) {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({ instanceNodes, wrapClass } = buildDecoratedClass(\n              ref,\n              path,\n              elements,\n              file,\n            ));\n          } else {\n            keysNodes = extractComputedKeys(path, computedPaths, file);\n            ({ staticNodes, pureStaticNodes, instanceNodes, wrapClass } =\n              buildFieldsInitNodes(\n                ref,\n                path.node.superClass,\n                props,\n                privateNamesMap,\n                file,\n                setPublicClassFields ?? loose,\n                privateFieldsAsSymbolsOrProperties ?? loose,\n                constantSuper ?? loose,\n                innerBinding,\n              ));\n          }\n        } else {\n          keysNodes = extractComputedKeys(path, computedPaths, file);\n          ({ staticNodes, pureStaticNodes, instanceNodes, wrapClass } =\n            buildFieldsInitNodes(\n              ref,\n              path.node.superClass,\n              props,\n              privateNamesMap,\n              file,\n              setPublicClassFields ?? loose,\n              privateFieldsAsSymbolsOrProperties ?? loose,\n              constantSuper ?? loose,\n              innerBinding,\n            ));\n        }\n\n        if (instanceNodes.length > 0) {\n          injectInitialization(\n            path,\n            constructor,\n            instanceNodes,\n            (referenceVisitor, state) => {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (isDecorated) return;\n              }\n              for (const prop of props) {\n                // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n                if (t.isStaticBlock?.(prop.node) || prop.node.static) continue;\n                prop.traverse(referenceVisitor, state);\n              }\n            },\n          );\n        }\n\n        // rename to make ts happy\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath\n            .find(parent => parent.isStatement() || parent.isDeclaration())\n            .insertAfter(pureStaticNodes);\n        }\n      },\n\n      ExportDefaultDeclaration(path, { file }) {\n        if (!process.env.BABEL_8_BREAKING) {\n          if (file.get(versionKey) !== version) return;\n\n          const decl = path.get(\"declaration\");\n\n          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {\n            if (decl.node.id) {\n              // export default class Foo {}\n              //   -->\n              // class Foo {} export { Foo as default }\n              splitExportDeclaration(path);\n            } else {\n              // @ts-expect-error Anonymous class declarations can be\n              // transformed as if they were expressions\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      },\n    },\n  };\n}\n"],"mappings":"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"}