{"version":3,"names":["_t","isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","parse","codeFrameColumns","PATTERN","parseAndBuildMetadata","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","validate","syntactic","placeholders","placeholderNames","Set","legacy","isLegacyRef","value","undefined","placeholderVisitorHandler","Object","assign","node","ancestors","state","_state$placeholderWhi","name","Error","test","has","slice","parent","key","length","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","i","index","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","err","loc","message","start"],"sources":["../src/parse.ts"],"sourcesContent":["import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors, TraversalHandler } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options\";\nimport type { Formatter } from \"./formatters\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const syntactic: MetadataState[\"syntactic\"] = {\n    placeholders: [],\n    placeholderNames: new Set(),\n  };\n  const legacy: MetadataState[\"legacy\"] = {\n    placeholders: [],\n    placeholderNames: new Set(),\n  };\n  const isLegacyRef: MetadataState[\"isLegacyRef\"] = { value: undefined };\n\n  traverse(ast, placeholderVisitorHandler as TraversalHandler<any>, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  });\n\n  return {\n    ast,\n    ...(isLegacyRef.value ? legacy : syntactic),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (\n    !state.isLegacyRef.value &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    state.isLegacyRef.value &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = state.isLegacyRef.value\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  isLegacyRef: {\n    value?: boolean;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n"],"mappings":"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"}