{"version":3,"names":["getBindingIdentifiers","isExpression","isExpressionStatement","isVariableDeclaration","isIfStatement","isBlockStatement","isEmptyStatement","sequenceExpression","assignmentExpression","conditionalExpression","cloneNode","gatherSequenceExpressions","nodes","scope","declars","exprs","ensureLastUndefined","node","push","expression","kind","declar","declarations","bindings","key","Object","keys","id","init","consequent","buildUndefinedNode","alternate","test","body","indexOf","length"],"sources":["../../src/converters/gatherSequenceExpressions.ts"],"sourcesContent":["import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers\";\nimport {\n  isExpression,\n  isExpressionStatement,\n  isVariableDeclaration,\n  isIfStatement,\n  isBlockStatement,\n  isEmptyStatement,\n} from \"../validators/generated\";\nimport {\n  sequenceExpression,\n  assignmentExpression,\n  conditionalExpression,\n} from \"../builders/generated\";\nimport cloneNode from \"../clone/cloneNode\";\nimport type * as t from \"..\";\nimport type { Scope } from \"@babel/traverse\";\n\nexport type DeclarationInfo = {\n  kind: t.VariableDeclaration[\"kind\"];\n  id: t.Identifier;\n};\n\nexport default function gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  scope: Scope,\n  declars: Array<DeclarationInfo>,\n) {\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: cloneNode(bindings[key]),\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], scope, declars)\n        : scope.buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], scope, declars)\n        : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      // bailed, we can't turn this statement into an expression\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\n"],"mappings":"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"}